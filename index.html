<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Duck Colony</title>
    <style>
        body {
	    background: url('your-image.gif') no-repeat center center fixed;
            font-family: monospace;
        }

        h1 {
            text-align: center;
            margin: 0;
        }

        h3 {
            text-align: center;
            margin: 0;
        }

        .label {
            font-weight: bold;
        }

        #window {
            overflow: scroll;
            position: absolute;
            top: 50%;
            left: 50%;
            height: calc(100vh - 80px);
            width: calc(100vw - 80px);
            border-color: black;
            border-style: solid;
            border-width: 1px;
            transform: translate(-50%, -50%);
            display: flex;
            text-align: center;
            justify-content: center;
            align-items: center;
        }

        #legend {
            position: absolute;
            min-height: 250px;
            min-width: 180px;
            border-width: 1px;
            border-style: solid;
            border-color: black;
            bottom: 15px;
            left: 15px;
            padding: 10px;
            background-color: white;
        }

        #banner {
            position: absolute;
            border-width: 1px;
            border-style: solid;
            border-color: black;
            padding: 10px;
            min-height: 40px;
            right: 80px;
            bottom: 15px;
            justify-self: center;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <div id="window">
        <div id="root"></div>
    </div>
    <div id="legend">
        <h1>Colony</h1>
        <br />
        <span class="label">Mama(s): </span><span id="Mamas"></span>
        <br />
        <span class="label">Duck(s): </span><span id="Ducks"></span>
        <br />
        <span class="label">Food: </span><span id="food"></span>
        <br />
        <span class="label">Tiles Explored: </span><span id="tiles"></span>
        <br />
        <span class="label">Time: </span><span id="ticks"></span><span> ticks</span>
        <br />
        <br />
        <h1>Stats</h1>
        <br />
        <span class="label">Food Drop Chance: </span><span id="foodDrop"></span><span>%</span>
        <br />
        <span class="label">Mama Birth Chance: </span><span id="MamaBirth"></span><span>%</span>
        <br />
        <span class="label">Time Until Birth: </span><span id="timeUntilBirth"></span><span> ticks</span>
    </div>

<pre>
 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$$$$P*""       ""*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$""  .zeP  .  4e..  "*$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$"  z$$$$P  d$b  "$$$b.  *$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$"  e$$$$$F  d$$$b  "$$$$$. ^*$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$" .$$$$$$"  d$$$$$b  '$$$$$b  *$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$% .$$$$$$"  d$$$$$$$b  ^$$$$$b  $$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$                                         4$$$$$$$$$$$$$$$$
 $$$$$$$$$$$F  $$$$$%  d$$$$$$$$$$$$  ^$$$$F  $$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$b  $$$$"  $$$$$$$$$$$$$$$.  $$$F  $$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$  '$$"  $$$$$$$$$$$$$$$$$.  $$  J$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$b  ""  $$$$$$$$$$$$$$$$$$$.  " .$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$b    $$$$$$$$$$$$$$$$$$$$$.  .$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$.  "$$$$$$$$$$$$$$$$$$P"  d$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$b.  ^"*$$$$$$$$$$$*"  .e$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$$b.      """     .e$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$$$$$$$beeeeeee$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


                      ..ed$$$$$$$ee.
                   zd$$*"".$$*$$F"**$$e.
                 d$$"    .$$" ^$$c   ^*$$.
               z$$"     4$$"   ^$$c     *$b.
              d$P      z$$"     ^$$L     ^$$.
             J$P      z$$"       ^$$b     ^$$
         $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$F
            4$$     J$$"            $$b    4$$
            ^$$    d$$               *$$   4$$
             $$L  d$$                 *$$  $$%
             ^$$cd$$                   *$$d$P
              ^$$$$                     *$$P
                *$$c                  .d$$"
                 ^*$$bc.           .e$$P"
                    ^*$$$$$$eee$$$$$*"   
                         ^"""""""%   

</pre>
</body>

<script>

    // elements
    const root = document.getElementById("root");
    const MamasEle = document.getElementById("Mamas");
    const DucksEle = document.getElementById("Ducks");
    const foodEle = document.getElementById("food");
    const tilesEle = document.getElementById("tiles");
    const timeEle = document.getElementById("ticks");
    const foodDropEle = document.getElementById("foodDrop");
    const MamaBirthEle = document.getElementById("MamaBirth");
    const timeUntilBirthEle = document.getElementById("timeUntilBirth");

    // static variables
    const drawTime = 50;
    const tickTime = 50;
    const foodChance = 0.03;
    const MamaChance = 0.02;
    const birthTime = 30;
    const ObjectType = { // enum for object types
        WALL: 0,
        Duck: 1,
        FOOD: 2
    };

    // maps
    const grid = {}; // true = dug out |  false = full
    const objects = {}; // holds all classes

    // variables
    let MamaCount = 0;
    let DuckCount = 0;
    let tickCount = 0;
    let foodCount = 0;
    let minX = 0;
    let maxX = 0;
    let minY = 0;
    let maxY = 0;
    let idIncrement = 0;
    let ticking = false; //in case of lag, this will avoid double ticking on the same tick.
    let drawing = false; //in case of lag, this will avoid double drawing on the same draw.

    /**
     * Default Class for all Objects in the world
     */
    class WorldObject {
        // override these
        letter;
        objectType;

        // set in constructor
        x;
        y;
        id;

        constructor(x, y) {
            idIncrement++;
            this.id = idIncrement;
            this.x = x;
            this.y = y;
            const newCoord = coord(x, y);
            objects[newCoord] = { ...objects[coord(x, y)], [this.id]: this };
            grid[newCoord] = true;
        }

        die() {
            delete objects[coord(this.x, this.y)][this.id];
        }
    }

    class Food extends WorldObject {
        objectType = ObjectType.FOOD;
        foodLeft = 3;
        letter = this.foodLeft.toString();

        constructor(x, y) {
            super(x, y);
            foodCount += this.foodLeft;
        }

        eat() {
            foodCount--;
            this.foodLeft--;
            if (this.foodLeft <= 0) {
                this.die();
            }
            this.letter = this.foodLeft.toString(10);
        }
    }

    /**
     * The ducky Class that has the ability to take basic actions
     * extend upon this class for all other objects
     */
    class ducky extends WorldObject {
        // override these
        hungerMax;
        hungerRate;
        delay;

        // set in constructor
        wait;
        hunger;
        lastDirection = "bottom";

        constructor(x, y) {
            super(x, y);
            this.wait = this.delay;
        }

        die() {
            super.die();
            new Food(this.x, this.y);
        }

        takeTurn(action = () => { }) {
            // check hunger
            this.hunger -= this.hungerRate;
            if (this.hunger <= 0) {
                this.die();
                return;
            }

            if (this.wait > 0) {
                this.wait--;
                return;
            }

            this.wait = this.delay;
            action();
        }

        move(direction) {
            const lastCoord = coord(this.x, this.y);
            delete objects[lastCoord][this.id];
            if (Object.keys(objects[lastCoord]).length < 1) {
                delete objects[lastCoord];
            }
            switch (direction) {
                case ("left"):
                    this.x = this.x - 1;
                    if (this.x < minX) {
                        minX = this.x;
                    }
                    break;
                case ("top"):
                    this.y = this.y - 1;
                    if (this.y < minY) {
                        minY = this.y;
                    }
                    break;
                case ("bottom"):
                    this.y = this.y + 1;
                    if (this.y > maxY) {
                        maxY = this.y;
                    }
                    break;
                case ("right"):
                    this.x = this.x + 1;
                    if (this.x > maxX) {
                        maxX = this.x;
                    }
                    break;
            }
            const newCoord = coord(this.x, this.y);
            if (!grid[newCoord] && Math.random() < foodChance) {
                new Food(this.x, this.y);
            }
            grid[newCoord] = true;
            objects[newCoord] = {
                ...objects[newCoord],
                [this.id]: this
            };
        }
    }

    /**
     * this is the Duck capable of making new tunnels and looking for food
     */
    class Duck extends ducky {
        letter = "~\_o<";
        delay = 1;
        hungerMax = 100;
        hungerRate = 1;
        objectType = ObjectType.Duck;

        constructor(x, y) {
            super(x, y);
            DuckCount++;
            this.hunger = this.hungerMax;
        }

        die() {
            super.die();
            DuckCount--;
        }

        takeTurn(action = () => { }) {
            super.takeTurn(() => {
                const [priorities, distanceNegative] = this.getPriorities();
                const direction = priorityDirection(
                    sight(this.x, this.y),
                    priorities,
                    this.lastDirection,
                    distanceNegative
                );
                this.move(direction);

                // eat if necessary
                if (this.hunger < (this.hungerMax - (this.hungerRate * 10))) {
                    const checkCoord = coord(this.x, this.y);
                    let _objects = Object.values(objects[checkCoord]);
                    _objects = _objects.filter(o => o.objectType === ObjectType.FOOD);
                    if (_objects.length > 0) {
                        _objects[0].eat();
                        this.hunger = this.hungerMax;
                    }
                }

                action();
            });
        }

        getPriorities() {
            const priorities = [ObjectType.WALL];
            if ((this.hunger / this.hungerMax) < 0.5) {
                priorities.unshift(ObjectType.FOOD);
            }
            return [priorities, this.hunger / this.hungerMax];
        }
    }

    class Mama extends Duck {
        letter = "~\_O<〰QUACK!";
        delay = 3;
        hungerMax = 500;
        hungerRate = 1;
        birthTime = birthTime;
        birthCount = 0;

        constructor(x, y) {
            super(x, y);
            MamaCount++;
            this.hunger = this.hungerMax;
        }

        die() {
            super.die();
            MamaCount--;
        }

        takeTurn(action = () => { }) {
            super.takeTurn(() => {
                this.birthCount++;
                if (this.birthCount >= this.birthTime) {
                    this.birthCount = 0;
                    if (Math.random() < MamaChance) {
                        new Mama(this.x + 1, this.y);
                    } else {
                        new Duck(this.x + 1, this.y);
                    }
                }
                action();
            });
        }
    }

    /**
     * Function for drawing the world
     * TODO: only draw the new parts of the world, right now it iterates over the whole thing
     */
    function draw() {
        if (drawing) {
            return;
        }
        drawing = true;
        // map
        let x;
        let y;
        let tilesExplored = 0;
        let text = "";
        for (y = minY; y <= maxY; y++) {
            for (x = minX; x <= maxX; x++) {
                const curObjects = objects[coord(x, y)];

                if (curObjects) {
                    tilesExplored++;
                    text += Object.values(curObjects)[0].letter;
                    continue;
                }

                if (!grid[`${x},${y}`]) {
                    text += "░";
                    continue;
                }

                tilesExplored++;
                const [left, top, bottom, right] = adjacent(x, y);

                // ╣
                if (left && top && bottom && !right) {
                    text += "╣";
                }
                // ║
                else if (!left && top && bottom && !right) {
                    text += "║";
                }
                // ╗
                else if (left && !top && bottom && !right) {
                    text += "╗";
                }
                // ╝
                else if (left && top && !bottom && !right) {
                    text += "╝";
                }
                // ╚
                else if (!left && top && !bottom && right) {
                    text += "╚";
                }
                // ╔
                else if (!left && !top && bottom && right) {
                    text += "╔";
                }
                // ╩
                else if (left && top && !bottom && right) {
                    text += "╩";
                }
                // ╦
                else if (left && !top && bottom && right) {
                    text += "╦";
                }
                // ╠
                else if (!left && top && bottom && right) {
                    text += "╠";
                }
                // ═
                else if (left && !top && !bottom && right) {
                    text += "═";
                }
                // ╬
                else if (left && top && bottom && right) {
                    text += "╬";
                } else {
                    text += "░";
                }
            }
            text += "\n";
        }
        root.innerText = text;

        // legend
        MamasEle.innerText = MamaCount.toString();
        DucksEle.innerText = DuckCount.toString();
        foodEle.innerText = foodCount.toString();
        tilesEle.innerText = tilesExplored.toString();
        timeEle.innerText = tickCount.toString();
        foodDropEle.innerText = (foodChance * 100).toString();
        MamaBirthEle.innerText = (MamaChance * 100).toString();
        timeUntilBirthEle.innerText = birthTime.toString();
        drawing = false;
    }


    /**
     * Iterates over all duckys and makes them take their turn
     */
    function tick() {
        if (!ticking) {
            ticking = true;
            Object.values(objects).forEach(duckys => {
                Object.values(duckys).forEach(ducky => {
                    if (ducky.takeTurn) {
                        ducky.takeTurn();
                    }
                });
            });
            tickCount++;
            ticking = false;
        }
    }

    /**
     * Utility for getting surroundings at a coord
     */
    function adjacent(x, y) {
        const left = grid[coord(x - 1, y)];
        const top = grid[coord(x, y - 1)];
        const bottom = grid[coord(x, y + 1)];
        const right = grid[coord(x + 1, y)];
        return [left, top, bottom, right];
    }

    /**
     * Utility for getting sight in straight lines. Gives the array and distance
     * [[Array<ObjectType>, number], x4]
     */
    function sight(x, y) {
        let _x;
        let _y;
        let left;
        let top;
        let bottom;
        let right;

        // left
        _x = x - 1;
        while (!left) {
            left = scan(_x, y);
            if (left) {
                left = [left, Math.abs(x - _x)];
            }
            _x--;
        }

        // top
        _y = y - 1;
        while (!top) {
            top = scan(x, _y);
            if (top) {
                top = [top, Math.abs(y - _y)];
            }
            _y--;
        }

        // bottom
        _y = y + 1;
        while (!bottom) {
            bottom = scan(x, _y);
            if (bottom) {
                bottom = [bottom, Math.abs(y - _y)];
            }
            _y++;
        }

        // right
        _x = x + 1;
        while (!right) {
            right = scan(_x, y);
            if (right) {
                right = [right, Math.abs(x - _x)];
            }
            _x++;
        }

        return [left, top, bottom, right];
    }

    /**
     * Check a single spot and return the array of Objects
     */
    function scan(x, y) {
        const _coord = coord(x, y);
        const _objects = objects[_coord];
        if (_objects) {
            return Object.values(_objects).map(o => (o.objectType));
        }
        if (!grid[_coord]) {
            return [ObjectType.WALL];
        }
    }

    /**
     * Utility for making the coord key;
     */
    function coord(x, y) {
        return `${x},${y}`;
    }

    /**
     * Utility for determining priority direction based on sight.
     * DistanceNegative will make things less priority if farther away
     */
    function priorityDirection(sightArr, priorities, lastDirection, distanceNegative = 0) {
        const [
            [leftTypes, leftDistance],
            [topTypes, topDistance],
            [bottomTypes, bottomDistance],
            [rightTypes, rightDistance]
        ] = sightArr;

        const filter = t => (priorities.includes(t));
        const sort = (a, b) => (priorities.indexOf(a) - priorities.indexOf(b));

        let bestLeft = priorities.indexOf(
            leftTypes
                .filter(filter)
                .sort(sort)[0]
        );
        bestLeft < 0 ?
            bestLeft = Number.MAX_SAFE_INTEGER :
            bestLeft += leftDistance * distanceNegative;

        let bestTop = priorities.indexOf(
            topTypes
                .filter(filter)
                .sort(sort)[0]
        );
        bestTop < 0 ?
            bestTop = Number.MAX_SAFE_INTEGER :
            bestTop += topDistance * distanceNegative;

        let bestBottom = priorities.indexOf(
            bottomTypes
                .filter(filter)
                .sort(sort)[0]
        );
        bestBottom < 0 ?
            bestBottom = Number.MAX_SAFE_INTEGER :
            bestBottom += bottomDistance * distanceNegative;

        let bestRight = priorities.indexOf(
            rightTypes
                .filter(filter)
                .sort(sort)[0]
        );
        bestRight < 0 ?
            bestRight = Number.MAX_SAFE_INTEGER :
            bestRight += rightDistance * distanceNegative;

        let list = [
            [bestLeft, "left"],
            [bestTop, "top"],
            [bestBottom, "bottom"],
            [bestRight, "right"]
        ];

        list = list.sort((a, b) => (a[0] - b[0]));
        let lowest = list[0][0];
        list = list.filter(p => p[0] <= lowest);
        return list[Math.floor(Math.random() * list.length)][1];
    }

    // start with 1 Mama
    new Mama(0, 0);

    setInterval(tick, tickTime);
    setInterval(() => window.requestAnimationFrame(draw), drawTime);


</script>
</html>
